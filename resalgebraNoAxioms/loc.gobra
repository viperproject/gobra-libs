// Copyright 2025 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

pkgInvariant GlobalMem() // todo: replace this by a dup invariant that GlobalMem() is an invariant
package resalgebraNoAxioms

// TODO:
// - use Monoset and monomap for the model, copy to this package if need be; delete cooliosetio and mapio
// - add triggers to invariants

// At the moment, all of these definitions are trusted, and this,
// prone to mistakes. If possible, we should find a model for the
// predicate GhostLocation and for all lemmas.

ghost type LocName gpointer[int]

/***** GhostLocation *****/

ghost
requires ra != nil
requires ra.IsElem(e) && ra.IsValid(e)
ensures  l != nil
ensures  GhostLocation(l, ra, e)
decreases
func Alloc(ra RA, e Elem) (l LocName) {
	l, w := AllocW(ra, e)
	assert GhostLocationW(l, ra, e, w)
	IntroExists(l, ra, e, w)
}

ghost
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocation(l, ra, ra.Compose(e1, e2))
ensures  GhostLocation(l, ra, e1) && GhostLocation(l, ra, e2)
decreases
func GhostOp1(l LocName, ra RA, e1 Elem, e2 Elem) {
	w := ElimExists(l, ra, ra.Compose(e1, e2))
	w1, w2 := GhostOp1W(l, ra, e1, e2, w)
	IntroExists(l, ra, e1, w1)
	IntroExists(l, ra, e2, w2)
}

ghost
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocation(l, ra, e1) && GhostLocation(l, ra, e2)
ensures  GhostLocation(l, ra, ra.Compose(e1, e2))
decreases
func GhostOp2(l LocName, ra RA, e1 Elem, e2 Elem) {
	w1 := ElimExists(l, ra, e1)
	w2 := ElimExists(l, ra, e2)
	GhostOp2W(l, ra, e1, e2, w1, w2)
	IntroExists(l, ra, ra.Compose(e1, e2), w1)
}

ghost
requires ra != nil
requires GhostLocation(l, ra, e)
ensures  GhostLocation(l, ra, e)
ensures  ra.IsElem(e) && ra.IsValid(e)
decreases
func GhostValid(l LocName, ra RA, e Elem) {
	w := ElimExists(l, ra, e)
	GhostValidW(l, ra, e, w)
	IntroExists(l, ra, e, w)
}

// Slightly different from paper, only captures a deterministic update.
// Non-deterministic update can be easily supported too.
ghost
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocation(l, ra, e1)
requires IsFramePreservingUpdate(ra, e1, e2)
ensures  GhostLocation(l, ra, e2)
decreases
func GhostUpdate(l LocName, ra RA, e1 Elem, e2 Elem) {
	w := ElimExists(l, ra, e1)
	GhostUpdateW(l, ra, e1, e2, w)
	IntroExists(l, ra, e2, w)
}

/***** Frame-Preserving Updates *****/

ghost
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
decreases
pure func IsFramePreservingUpdate(ra RA, e1 Elem, e2 Elem) bool {
	return forall c option[Elem] :: { LiftedCompose(ra, some(e1), c) } { LiftedCompose(ra, some(e2), c) } (c !== none[Elem] ==> ra.IsElem(get(c))) ==>
		(LiftedIsValid(ra, LiftedCompose(ra, some(e1), c)) ==> LiftedIsValid(ra, LiftedCompose(ra, some(e2), c)))
}

ghost
requires ra != nil
requires e1 !== none[Elem] ==> ra.IsElem(get(e1))
requires e2 !== none[Elem] ==> ra.IsElem(get(e2))
decreases
pure func LiftedCompose(ra RA, e1 option[Elem], e2 option[Elem]) option[Elem] {
	return e1 === none[Elem] ?
		e2 :
		(e2 === none[Elem] ?
			e1 :
			some(ra.Compose(get(e1), get(e2))))
}

ghost
requires ra != nil
requires e !== none[Elem] ==> ra.IsElem(get(e))
decreases
pure func LiftedIsValid(ra RA, e option[Elem]) bool {
	return e !== none[Elem] ?
		ra.IsValid(get(e)) :
		true
}

/***** Model: Global State *****/

// TODO: IsInv(GlobalMem()) should be established by init
pred GlobalMem() {
	inv(model) &&
	ras.Inv()  &&
	// necessary for proving key freshness
	(forall k LocName :: k elem domain(toDict(model)) ==> acc(k, 1/2)) &&
	(forall k LocName :: { k elem domain(toDict(model)) } { ras.ToDict()[k] } k elem domain(toDict(model)) ==>
		k elem domain(ras.ToDict())) &&
	(forall k LocName :: { k elem domain(ras.ToDict()) }{ ras.ToDict()[k] } k elem domain(ras.ToDict()) ==>
		ras.ToDict()[k] != RA(nil)) &&
	// injectivity
	(forall k1, k2 LocName :: k1 elem domain(toDict(model)) && k2 elem domain(toDict(model)) && k1 != k2 ==>
		toDict(model)[k1] != toDict(model)[k2]) &&
	(forall k LocName :: k elem domain(toDict(model)) ==> toDict(model)[k].Inv()) &&
	// injectivity
	(forall k1, k2 LocName :: k1 elem domain(toDict(model)) && k2 elem domain(toDict(model)) && k1 != k2 ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k1]) ==> !(i elem toCoolSet(toDict(model)[k2])))) &&
	(forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==> acc(i, 1/2))) &&
	(forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
			i.inUse ==> (ras.ToDict()[k].IsElem(i.val) && ras.ToDict()[k].IsValid(i.val)))) &&
	(forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
			i.inUse ==> (
				forall i2 idx :: i2 elem toCoolSet(toDict(model)[k]) && i2.inUse && i2 !== i ==>
					ras.ToDict()[k].IsElem(ras.ToDict()[k].Compose(i.val, i2.val)) &&
					ras.ToDict()[k].IsValid(ras.ToDict()[k].Compose(i.val, i2.val)))))
}

ghost var model cooliomapio = allocMap()
ghost var ras rasMap = rasMapAlloc()

func init() {
	fold GlobalMem()
}

/***** Model *****/

ghost type idx gpointer[meta]

ghost type Witness ghost struct {
	i idx
	c cooliosetio
}

ghost type meta ghost struct {
	inUse bool
	val Elem
}

pred GhostLocationW(l LocName, ra RA, e Elem, w Witness) {
	acc(w.i, 1/2)          &&
	witness(model, l, w.c) &&
	w.c.witness(w.i)       &&
	ra != nil              &&
	w.i.val === e          &&
	ra.IsElem(w.i.val)     &&
	ra.IsValid(w.i.val)    &&
	ras.Witness(l, ra)
}

/***** Model: functions that do not acquire global invariant; these functions may be called from critical regions *****/

ghost
requires GlobalMem()
requires ra != nil
requires ra.IsElem(e) && ra.IsValid(e)
ensures  GlobalMem()
ensures  l != nil
ensures  GhostLocationW(l, ra, e, w)
decreases
func AllocWI(ra RA, e Elem) (l LocName, w Witness) {
	unfold GlobalMem()

	newl := new(int)
	var cs cooliosetio = allocSet()
	iii := &meta{true, e}
	cs.add(iii)
	add(model, newl, cs)
	assert witness(model, newl, cs)
	newi := Witness{iii, cs}
	rasDict := ras.ToDict()
	assume !(newl elem domain(rasDict))
	ras.Insert(newl, ra)
	fold GhostLocationW(newl, ra, e, newi)

	assert acc(newl, 1/2)
	assert forall k LocName :: k elem domain(toDict(model)) ==> acc(k, 1/2)
	assert forall k LocName :: k elem domain(toDict(model)) ==> k elem domain(ras.ToDict())
	assert forall k LocName :: k elem domain(ras.ToDict()) ==> ras.ToDict()[k] != RA(nil)

	// problem with triggers?
	assume forall k1, k2 LocName :: k1 elem domain(toDict(model)) && k2 elem domain(toDict(model)) && k1 != k2 ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k1]) ==> !(i elem toCoolSet(toDict(model)[k2])))
	assume forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==> acc(i, 1/2))
	assert forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
			i.inUse ==> (ras.ToDict()[k].IsElem(i.val) && ras.ToDict()[k].IsValid(i.val)))
	fold GlobalMem()

	return newl, newi
}

ghost
requires GlobalMem()
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, ra.Compose(e1, e2), w)
ensures  GlobalMem()
ensures  GhostLocationW(l, ra, e1, w1) && GhostLocationW(l, ra, e2, w2)
decreases
func GhostOp1WI(l LocName, ra RA, e1 Elem, e2 Elem, w Witness) (w1 Witness, w2 Witness) {
	i := w
	unfold GlobalMem()
	unfold GhostLocationW(l, ra, ra.Compose(e1, e2), i)

	ras.DupWitness(l, ra)
	ras.WitnessInMap(l, ra, 1/10)
	assert witness(model, l, i.c)
	lemmaWitness(model, l, i.c, 1/3)
	assert toDict(model)[l] === i.c
	assert i.c.witness(i.i)
	i.c.lemmaWitness(i.i, 1/3)
	assert i.i elem toCoolSet(i.c)
	ValidOp(ra, e1, e2)
	assert ra.IsValid(e1)
	ComposeComm(ra, e1, e2)
	ValidOp(ra, e2, e1)
	assert ra.IsValid(e2)

	i.i.inUse = false
	iii1 := &meta{true, e1}
	dupWitness(model, l, i.c)
	i.c.add(iii1)
	i1 := Witness{iii1, i.c}
	ras.DupWitness(l, ra)
	fold GhostLocationW(l, ra, e1, i1)

	iii2 := &meta{true, e2}
	i.c.add(iii2)
	assert witness(model, l, i.c)
	i2 := Witness{iii2, i.c}
	fold GhostLocationW(l, ra, e2, i2)

	assume forall k1, k2 LocName :: k1 elem domain(toDict(model)) && k2 elem domain(toDict(model)) && k1 != k2 ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k1]) ==> !(i elem toCoolSet(toDict(model)[k2])))

	// not hard to prove, requires applying commutativity and associativity to get (i1 x i2) x k == (i1 x k) x i2. Because the lhs is valid, the rhs is also valid, and by ValidOp, i1 x k is also valid
	// TODO: requires changing the API of RAs so that all lemmas are universally quantified
	assume forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
			i.inUse ==> (
				forall i2 idx :: i2 elem toCoolSet(toDict(model)[k]) && i2.inUse && i2 !== i ==>
					ras.ToDict()[k].IsElem( ras.ToDict()[k].Compose(i.val, i2.val)) &&
					ras.ToDict()[k].IsValid(ras.ToDict()[k].Compose(i.val, i2.val))))

	fold GlobalMem()
	return i1, i2
}

ghost
requires GlobalMem()
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, e1, w1) && GhostLocationW(l, ra, e2, w2)
ensures  GlobalMem()
ensures  GhostLocationW(l, ra, ra.Compose(e1, e2), w1)
decreases
func GhostOp2WI(l LocName, ra RA, e1 Elem, e2 Elem, w1 Witness, w2 Witness) {
	i1 := w1
	i2 := w2

	unfold GlobalMem()

	unfold GhostLocationW(l, ra, e1, i1)
	unfold GhostLocationW(l, ra, e2, i2)
	lemmaWitness(model, l, i2.c, 1/3)
	assert i2.c === toDict(model)[l]
	i2.c.lemmaWitness(i2.i, 1/3)
	assert i2.i elem toCoolSet(i2.c)
	i2.i.inUse = false

	lemmaWitness(model, l, i1.c, 1/3)
	i1.c.lemmaWitness(i1.i, 1/3)
	i1.i.val = ra.Compose(e1, e2)
	// triggering issue ?
	assume ra.IsElem(ra.Compose(e1, e2)) && ra.IsValid(ra.Compose(e1, e2))
	fold GhostLocationW(l, ra, ra.Compose(e1, e2), i1)

	// triggering issue
	assume forall k LocName :: k elem domain(toDict(model)) ==>
		  (forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
				  i.inUse ==> (ras.ToDict()[k].IsElem(i.val) && ras.ToDict()[k].IsValid(i.val)))

	// proof requires that all previous elems can be added to this one and become valid.
	// actually, the proof should be very similar to that of GhostOp1W
	assume forall k LocName :: k elem domain(toDict(model)) ==>
		(forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
				i.inUse ==> (
						forall i2 idx :: i2 elem toCoolSet(toDict(model)[k]) && i2.inUse && i2 !== i ==>
								ras.ToDict()[k].IsElem(ras.ToDict()[k].Compose(i.val, i2.val)) &&
								ras.ToDict()[k].IsValid(ras.ToDict()[k].Compose(i.val, i2.val))))


	fold GlobalMem()
}

ghost
requires GlobalMem()
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, e1, w)
requires IsFramePreservingUpdate(ra, e1, e2)
ensures  GlobalMem()
ensures  GhostLocationW(l, ra, e2, w)
decreases
func GhostUpdateWI(l LocName, ra RA, e1 Elem, e2 Elem, w Witness) {
	i := w
	unfold GlobalMem()

	unfold GhostLocationW(l, ra, e1, i)
	lemmaWitness(model, l, i.c, 1/3)
	i.c.lemmaWitness(i.i, 1/3)
	i.i.val = e2

	// TODO: can be proven easily as long as I can introduce an existentially quantified variable
	if forall e Elem :: ra.IsElem(e) ==> LiftedCompose(ra, some(e1), some(e)) === none[Elem] {
		assert ra.IsValid(e2)
	} else {
		// idea: if e1 has a core, than e2 must be valid: e1 has core ==>
		//	==> compose(e2, core(e1)) must be valid because compose(e1, core(e1)) is valid and e2 is a frame preserving update
		//	==> e2 is valid because the compose(e2, core(e1)) is valid.
		// what about the cases e1 does not have a core?
		assume ra.IsValid(e2) // TODO
	}

	// if ra.Core(e1) != none[Elem] {
	// 	ra.CoreId(e1)
	// 	assert ra.Compose(get(ra.Core(e1)), e1) === e1
	// 	ra.ComposeComm(get(ra.Core(e1)), e1)
	// 	assert ra.Compose(e1, get(ra.Core(e1))) === e1
	// 	assert LiftedIsValid(ra, some(e1))
	// 	assert LiftedIsValid(ra, some(ra.Compose(e1, get(ra.Core(e1)))))
	// 	IsFramePreservingUpdate(ra, e1, e2)
	// 	assume false // TODO
	// 	assert LiftedIsValid(ra, some(ra.Compose(e2, get(ra.Core(e1))))) // from def of frame-preserving update
	// } else {
	// 	// assume ra.IsValid(e2)
	// }

	ras.DupWitness(l, ra)
	ras.WitnessInMap(l, ra, 1/10)

	// TODO: should be provable from the def of IsFramePreservingUpdate
	assume forall k LocName :: k elem domain(toDict(model)) ==>
		  (forall i idx :: i elem toCoolSet(toDict(model)[k]) ==>
				  i.inUse ==> (
						  forall i2 idx :: i2 elem toCoolSet(toDict(model)[k]) && i2.inUse && i2 !== i ==>
								  ras.ToDict()[k].IsElem(ras.ToDict()[k].Compose(i.val, i2.val)) &&
								  ras.ToDict()[k].IsValid(ras.ToDict()[k].Compose(i.val, i2.val))))

	fold GhostLocationW(l, ra, e2, i)

	fold GlobalMem()
}

/***** Model: functions that do not depend on the global invariant *****/

ghost
requires ra != nil
requires GhostLocationW(l, ra, e, w)
ensures  GhostLocationW(l, ra, e, w)
ensures  ra.IsElem(e) && ra.IsValid(e)
decreases
func GhostValidW(l LocName, ra RA, e Elem, w Witness) {
	unfold GhostLocationW(l, ra, e, w)
	fold GhostLocationW(l, ra, e, w)
}

/***** Model: wrappers that acquire the global invariant; these functions may not be called from critical regions *****/

// TODO: IsInv(GlobalMem()) should be a duplicable invariant

ghost
// opensInvariants
requires ra != nil
requires ra.IsElem(e) && ra.IsValid(e)
ensures  l != nil
ensures  GhostLocationW(l, ra, e, w)
decreases
func AllocW(ra RA, e Elem) (l LocName, w Witness) {
	inhale GlobalMem() // acquire dup pkg invariant && open invariant
	l, w = AllocWI(ra, e)
	exhale GlobalMem() // close invariant
}

ghost
// opensInvariants
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, ra.Compose(e1, e2), w)
ensures  GhostLocationW(l, ra, e1, w1) && GhostLocationW(l, ra, e2, w2)
decreases
func GhostOp1W(l LocName, ra RA, e1 Elem, e2 Elem, w Witness) (w1 Witness, w2 Witness) {
	inhale GlobalMem() // acquire dup pkg invariant && open invariant
	w1, w2 = GhostOp1WI(l, ra, e1, e2, w)
	exhale GlobalMem() // close invariant
}

ghost
// opensInvariants
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, e1, w1) && GhostLocationW(l, ra, e2, w2)
ensures  GhostLocationW(l, ra, ra.Compose(e1, e2), w1)
decreases
func GhostOp2W(l LocName, ra RA, e1 Elem, e2 Elem, w1 Witness, w2 Witness) {
	inhale GlobalMem() // acquire dup pkg invariant && open invariant
	GhostOp2WI(l, ra, e1, e2, w1, w2)
	exhale GlobalMem() // close invariant
}

ghost
// opensInvariants
requires ra != nil
requires ra.IsElem(e1)
requires ra.IsElem(e2)
requires GhostLocationW(l, ra, e1, w)
requires IsFramePreservingUpdate(ra, e1, e2)
ensures  GhostLocationW(l, ra, e2, w)
decreases
func GhostUpdateW(l LocName, ra RA, e1 Elem, e2 Elem, w Witness) {
	inhale GlobalMem() // acquire dup pkg invariant && open invariant
	GhostUpdateWI(l, ra, e1, e2, w)
	exhale GlobalMem() // close invariant
}