// Copyright 2025 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package resalgebraNoAxioms

// sets that can only grow monotically. adding a new element to the set
// requires and ensures the set invariant, but checking that a value is in the set
// should not require the set inv

ghost type valSet = idx

ghost type nodeSet ghost struct {
	inUse bool
	next gpointer[nodeSet]
	v valSet
	p perm
}

// todo: change
ghost type cooliosetio gpointer[nodeSet]

pred (m cooliosetio) Inv() {
	acc(m, 1/2) &&
	(m.next == nil ==> !m.inUse && acc(m, 1/2)) &&
	(m.next != nil ==> 
		m.inUse &&
		acc(&m.p, 1/2) &&
		cooliosetio(m.next).Inv() &&
		m.p > 0                   &&
		acc(&m.inUse, m.p) && acc(&m.next, m.p) && acc(&m.v, m.p))
}

ghost
ensures m.Inv()
decreases
func allocSet() (m cooliosetio) {
	var g@ nodeSet
	var c cooliosetio = &g
	fold c.Inv()
	return c
}

ghost
requires m.Inv()
decreases m.Inv()
pure func toCoolSet(m cooliosetio) set[valSet] {
	return unfolding m.Inv() in (m.inUse ? (toCoolSet(m.next) union set[valSet]{m.v}) : set[valSet]{})
}

pred (m cooliosetio) witness(v valSet) {
	acc(&m.inUse, _) && acc(&m.next, _) && acc(&m.v, _) &&
	(!m.inUse ==> false) &&
	(m.v != v ==> cooliosetio(m.next).witness(v))
}

ghost
requires m.Inv()
ensures  m.Inv()
ensures  m.witness(v)
ensures  toCoolSet(m) === old(toCoolSet(m)) union set[valSet]{v}
decreases m.Inv()
func (m cooliosetio) add(v valSet) {
	unfold m.Inv()
	if !m.inUse {
		next@ := nodeSet{}
		assert acc(m)
		m.inUse = true
		m.p = 1/4
		m.next = &next
		m.v = v
		fold cooliosetio(m.next).Inv()
		fold m.Inv()
		fold m.witness(v)
	} else {
		cooliosetio(m.next).add(v)
		assert cooliosetio(m.next).witness(v)
		m.p = m.p/2
		fold m.Inv()
		fold m.witness(v)
	}
}

ghost
requires 0 < p
requires acc(m.Inv(), p)
requires m.witness(v)
ensures  acc(m.Inv(), p)
ensures  m.witness(v)
ensures  v elem toCoolSet(m)
decreases acc(m.Inv(), p)
func (m cooliosetio) lemmaWitness(v valSet, p perm) {
	d := toCoolSet(m)
	// here
	unfold acc(m.Inv(), p)
	unfold m.witness(v)
	if m.v == v {
		assert v elem d
	} else {
		cooliosetio(m.next).lemmaWitness(v, p)
	}
	fold acc(m.Inv(), p)
	fold m.witness(v)
}

ghost
requires m.witness(v)
ensures  m.witness(v) && m.witness(v)
decreases m.witness(v)
func (m cooliosetio) dupWitness(v valSet) {
	unfold m.witness(v)
	if m.v != v {
		cooliosetio(m.next).dupWitness(v)
	}
	fold m.witness(v)
	fold m.witness(v)
}