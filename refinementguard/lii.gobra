// Copyright 2026 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package refinementguard

// locally inductive inv
// Gobra disallows calling the methods bellow TS and EG due to name conflicts
type LII interface{
	ghost
	ensures res != nil
	decreases
	pure ITS() (res TransitionSystem)

	ghost
	ensures res != nil
	decreases
	pure IEG() (res EventGuard)

	ghost
	decreases
	pure Prop(s State) bool

	ghost
	decreases
	pure Guard() (res GuardV)

	ghost
	requires ITS().Enabled(s, e)
	requires Prop(s)
	ensures  !IEG().Requires(e, Guard()) ==> Prop(ITS().Update(s, e))
	decreases
	pure PreservedByTransitionsExcept(s State, e Event) Unit
}

// Focus on this one, ignore the previous ones
ghost
requires acc(&TS, _) && TS != nil
requires acc(&EG, _) && EG != nil
requires i != nil
requires i.ITS() === TS && i.IEG() === EG
requires Own()
requires GuardR(i.Guard())
requires i != nil
requires i.Prop(LastObservedState(i.Guard()))
ensures  i.Prop(CurrState())
decreases
pure func InstantiateLII(i LII) Unit {
	return let cs := CurrState()       in
		unfolding Own()                in
		unfolding GuardR(i.Guard())    in
		let trace := traces[i.Guard()] in
		let _ := Asserting(i.Guard() elem EG.Guards()) in
		let _ := Asserting(guardCompatibleWithState(TS, EG, i.Guard(), LastObservedState(i.Guard()), s, trace)) in
		let _ := Asserting(0 < len(trace)) in
		let _ := Asserting(trace[len(trace) - 1].s === cs) in
		instantiateLIIAux(i, traces[i.Guard()], 0)
}

ghost
requires acc(&TS, _) && TS != nil
requires acc(&EG, _) && EG != nil
requires i != nil
requires i.ITS() === TS && i.IEG() === EG
requires 0 < len(trace)
requires 0 <= currIdx && currIdx <= len(trace)
requires 0 <= currIdx && currIdx < len(trace) ==> i.Prop(trace[currIdx].s)
requires 0 <= currIdx && currIdx < len(trace) ==> i.Prop(trace[currIdx].s)
requires (forall idx int :: {trace[idx]} 0 < idx && idx < len(trace) ==>
	trace[idx].e != none[Event]                      &&
	!EG.Requires(get(trace[idx].e), i.Guard())       &&
	TS.Enabled(trace[idx-1].s, get(trace[idx].e))    &&
	trace[idx].s === TS.Update(trace[idx-1].s, get(trace[idx].e)))
ensures  forall idx int :: currIdx <= idx && idx < len(trace) ==> i.Prop(trace[idx].s)
decreases len(trace) - currIdx
pure func instantiateLIIAux(i LII, trace seq[traceEntry], currIdx int) Unit {
	return currIdx == len(trace) ?
		Unit{} :
		(currIdx == len(trace) - 1 ?
			Unit{} :
			let _ := i.PreservedByTransitionsExcept(trace[currIdx].s, get(trace[currIdx+1].e)) in
			let _ := Asserting(TS.Update(trace[currIdx].s, get(trace[currIdx+1].e)) === trace[currIdx+1].s) in
			let _ := Asserting(i.Prop(trace[currIdx+1].s)) in
			instantiateLIIAux(i, trace, currIdx+1))
}