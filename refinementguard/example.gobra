// Copyright 2025 ETH Zurich
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +gobra

package refinementguard

/*
type ts struct{}

type state struct {
	count int
}

type inc struct {
	delta int
}

ts implements TransitionSystem


// Definition of LTS: we may update the value of the counter,
// as long as it is always within bounds ([0..3])
ghost
decreases
pure func (t ts) Init(s State) bool {
	return s != nil              &&
		typeOf(s) == type[state] &&
		let st := s.(state)      in
		st.count == 0
}

ghost
decreases
pure func (t ts) Valid(s State) bool {
	return s != nil              &&
		typeOf(s) == type[state] &&
		let st := s.(state)      in
		0 <= st.count
}

ghost
decreases
pure func (t ts) Enabled(s State, e Event) bool {
	return t.Valid(s) && typeOf(e) == type[inc] ?
			(let ee := e.(inc)            in
			let st := s.(state)           in
			let nv := st.count + ee.delta in
			0 <= nv) :
		false
}

ghost
requires t.Enabled(s, e)
decreases
pure func (t ts) Update(s State, e Event) State {
	return let ee := e.(inc) in
		let st := s.(state)  in
		state{ st.count + ee.delta }
}

ghost
requires t.Valid(s)
requires t.Enabled(s, e)
ensures  let ns := t.Update(s, e) in
	ns != nil && t.Valid(ns)
decreases
func (t ts) UpdateValidIsValid(s State, e Event) {
	// proven
}

// end of definition of LTS

type IncDec bool

const Inc IncDec = true
const Dec IncDec = false


ghost
requires t != nil
decreases
pure func (i IncDec) Guards(t TransitionSystem) (ghost set[GuardV]) {
	return set[GuardV]{ GuardV(Inc), GuardV(Dec) }
}

ghost
requires t != nil
ensures  res ==> g elem i.Guards(t)
decreases
pure func (i IncDec) Requires(t TransitionSystem, e Event, g GuardV) (res bool) {
	return e != nil &&
		typeOf(e) == type[inc] &&
		let ee := e.(inc)      in
		ee.delta >= 0 ? g === Inc : g === Dec
}

IncDec implements EventGuard

requires Own()
requires TS() === ts{}
requires GuardR(TS(), GuardV(Inc))
requires i != nil
requires forall st state :: i.Prop(GuardV(Inc)) == (st.count <= 10)
requires i.Prop(LastObservedState(TS(), GuardV(Inc)))
func exampleLII(i LII) {
	st1 := CurrState().(state)
	ObserveLIIG(GuardV(Inc), i)
	assert st1.count <= 10
}
*/